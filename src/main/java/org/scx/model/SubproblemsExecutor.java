package org.scx.model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import ilog.cplex.IloCplex;

/**
 * 
 * Class in charge of executing subproblems in parallel
 *
 */
public class SubproblemsExecutor {

    private static final int MAX_THREADS = 4;

    /** Executors **/
    private final ExecutorService executor;
    /** Futures **/
    private final List<Future<IloCplex.Status>> futures;

    /** Subproblems **/
    private final List<ScenarioProblem> subproblems;

    /**
     * Creates a new subproblem executor
     *
     * @param pricingProblems
     *        List of pricing problems
     */
    public SubproblemsExecutor(Collection<ScenarioProblem> pricingProblems) {
        this.executor = Executors.newFixedThreadPool(MAX_THREADS);
        this.futures = new ArrayList<>(pricingProblems.size());
        this.subproblems = new ArrayList<>(pricingProblems);
    }

    /**
     * Solve the subproblems problems in parallel
     *
     * @param solver
     *        the solver which should be used to solve the subproblem(s)
     * @return List of status which have been generated by the solvers.
     */
    public Map<ScenarioProblem, IloCplex.Status> solveSubproblems() {


        // 1. schedule pricing problems
        Map<Future<IloCplex.Status>, ScenarioProblem> futureToSubproblem =
                new HashMap<Future<IloCplex.Status>, ScenarioProblem>();
        for (ScenarioProblem solverInstance : subproblems) {
            Future<IloCplex.Status> f = executor.submit(solverInstance);
            futureToSubproblem.put(f, solverInstance);
            futures.add(f);
        }

        // 2. Wait for completion and check whether any of the threads has thrown an exception which
        // needs to be handled upstream
        // 3. Collect and return results
        Map<ScenarioProblem, IloCplex.Status> subproblemToStatus = new HashMap<>();
        for (Future<IloCplex.Status> f : futures) {
            try {
                IloCplex.Status status = f.get(); // get is a blocking procedure
                ScenarioProblem subproblem = futureToSubproblem.get(f);
                subproblemToStatus.put(subproblem, status);
            } catch (ExecutionException e) {
                if (e.getCause() instanceof RuntimeException) {
                    this.shutdownAndAwaitTermination(executor); // Shut down the executor.
                    throw (RuntimeException) e.getCause(); // Propagate the exception
                } else {
                    e.printStackTrace();
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        futures.clear();
        return subproblemToStatus;
    }

    /**
     * Shut down the executors
     */
    private void shutdownAndAwaitTermination(ExecutorService pool) {
        // Prevent new tasks from being submitted
        pool.shutdownNow();
        try {
            // Wait a while for tasks to respond to being cancelled
            if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {
                System.err.println("Pool did not terminate");
            }
        } catch (InterruptedException ie) {
            // (Re-)Cancel if current thread also interrupted
            pool.shutdownNow();
            // Preserve interrupt nodeStatus
            Thread.currentThread().interrupt();
        }
    }

    /**
     * Close the pricing problems
     */
    public void close() {
        executor.shutdownNow();
    }

}
